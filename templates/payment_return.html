# routes/purchase.py
from flask import current_app
from sqlalchemy import select
from db import db
from models import Purchase, Payment, Ticket

@bp_purchase.get("/pay/return/<token>")
def pay_return(token: str):
    finalize_fn = current_app.extensions.get("finalize_purchase")

    with db() as s:
        purchase = s.scalar(select(Purchase).where(Purchase.token == token))
        if not purchase:
            abort(404)

        # ✅ 1) payment pago (se existir) — evita cair no pending errado
        payment_paid = s.scalar(
            select(Payment)
            .where(Payment.purchase_id == purchase.id, Payment.status == "paid")
            .order_by(Payment.id.desc())
        )

        # ✅ 2) senão, pega o último (pending/failed/expired)
        payment = payment_paid or s.scalar(
            select(Payment)
            .where(Payment.purchase_id == purchase.id)
            .order_by(Payment.id.desc())
        )

        tickets = list(
            s.scalars(
                select(Ticket)
                .where(Ticket.purchase_id == purchase.id)
                .order_by(Ticket.id.asc())
            )
        )

        # ✅ se já está pago, mas ainda não gerou links, tenta finalizar (idempotente)
        should_finalize = (
            payment
            and (payment.status or "").lower() == "paid"
            and not payment.tickets_pdf_url
            and callable(finalize_fn)
        )

    # ⚠️ chama fora do "with db()" pra não misturar sessão
    if should_finalize:
        try:
            finalize_fn(purchase.id)
        except Exception:
            pass

        # recarrega depois do finalize
        with db() as s:
            purchase = s.scalar(select(Purchase).where(Purchase.token == token))
            tickets = list(
                s.scalars(
                    select(Ticket)
                    .where(Ticket.purchase_id == purchase.id)
                    .order_by(Ticket.id.asc())
                )
            )
            payment = s.scalar(
                select(Payment)
                .where(Payment.purchase_id == purchase.id, Payment.status == "paid")
                .order_by(Payment.id.desc())
            ) or s.scalar(
                select(Payment)
                .where(Payment.purchase_id == purchase.id)
                .order_by(Payment.id.desc())
            )

    return render_template(
        "payment_return.html",
        purchase=purchase,
        payment=payment,
        tickets=tickets,          # ✅ AGORA TEM
        app_name=os.getenv("APP_NAME", "Sons & Sabores"),
    )
